# interview-question
기술면접 대비용 질문 정리 레포지토리입니다 

## 답변할 때 생각할 점
### 최대한 짧고 간결하게 답변한다.
- 너무 디테일하게 말하면 불리해질 수 있다. 핵심을 중심으로 간결하게 답변하고 꼬리질문에 대응하는 게 유리하다.

### 모르는 내용은 솔직하게 모른다고 답변한다.


## 운영체제
<details>
<summary>프로세스와 스레드의 차이에 대해서 설명해주세요.</summary>
<div markdown="1">       


프로세스는 메모리에 올라가서 실행되고 있는 프로그램입니다. 모든 프로세스는 code/data/heap/stack으로 이루어진 독자적인 주소공간을 가지고 있습니다.
반면 스레드는 프로세스 내에서 가지는 실행의 흐름입니다. 하나의 프로세스에서 여러 스레드를 통해 동시에 여러 작업을 처리할 수 있습니다.
스레드들은 프로세스의 스택을 제외한 주소 공간을 공유할 수 있습니다.
그렇기 때문에 공유 영역의 자원을 사용할 때는 동기화 문제를 염두에 두어야 합니다.

</div>
</details>

<details>
<summary>스레드에 대해서 설명해주세요</summary>
<div markdown="1">


스레드는 프로세스 내에서 실행되는 흐름의 단위입니다. 프로세스의 주소 영역 중 code, data, heap을 공유합니다.
독자적인 실행을 위해 PC와 stack 등의 영역은 독자적으로 가집니다. 이런 특성 때문에 스레드 간 context switch는 프로세스의 경우보다 가볍습니다.
그렇지만 한 프로세스 내에서 메모리 영역을 공유하고 있으니, heap 영역의 객체를 사용할 때 동기화 문제가 발생할 수 있습니다.
때문에 싱글 스레드에서는 고려하지 않던 동기화 문제 해결을 위해 lock, semaphore, monitor 등의 방법을 고민해야합니다.

그리고 무조건 스레드를 만드는 것이 유리하냐? 라고 생각할 수 있습니다.
하지만 스레드를 만드는 것 또한 비용이 많이 드는 작업이므로 스레드를 무조건 많이 만든다고 해서 좋지 않습니다.
이론 상 코어의 개수만큼만 스레드가 동시에 작업이 가능하므로 코어의 개수에 맞게 스레드를 설계하는 것이 좋습니다.
이와 관련하여 하이퍼쓰레딩 기술은 한 코어당 두 개의 스레드를 작업할 수 있도록 하여 멀티태스킹 능력을 향상시켰습니다.

</div>
</details>

<details>
<summary>* 동기와 비동기, 블로킹과 논블로킹의 차이에 대해 설명해주세요.</summary>
<div markdown="1">


먼저 동기와 비동기에 대해 설명해보겠습니다. 동기는 Synchronous이므로 시간을 맞춘다는 의미입니다.
메서드를 리턴하는 시간에 결과를 전달받는 시간과 일치하면 동기, 일치하지 않으면 비동기입니다.
리턴하는 시점과 결과를 전달받는 시점이 다르다는 것은 무엇일까요?

이 때 등장하는 개념이 Future입니다. 비동기적으로 실행한 함수의 결과는 일반적인 타입으로 받아올 수 없습니다.
Java에서는 Future라는 형태로 비동기적으로 실행한 함수의 결과를 받아올 수 있습니다.
리턴하는 시점이 아닌, 그 결과를 필요해서 꺼낼 때 전달받으므로 비동기적으로 실행한다고 볼 수 있습니다.

이 때 비동기 작업의 결과가 출력될 때 직접 꺼내는 것이 아닌 콜백을 통해 어떤 작업을 실행하도록 할 수도 있습니다.
자바의 `ListenableFuture` 라는 인터페이스를 활용하여 콜백을 등록하거나, `CompletableFuture`의 `then~()`를 사용할 수도 있습니다.

블로킹과 논블로킹은 함수 호출 후 제어권을 돌려받는 지 아닌지에 대한 영역입니다.
https://www.youtube.com/watch?v=HKlUvCv9hvA

위 링크에 따르면, 내가 직접 제어할 수 없는 대상을 상대하는 방법입니다. I/O를 한다든지, 멀티 스레드 동기화에 해당합니다.
쉽게 말하면 어떤 작업을 시킨 다음 작업이 모두 끝날 때까지 기다렸다가 실행하는 방식입니다.
논블로킹 방식은 어떤 작업을 시킨 다음 곧장 빠져나와서 자신의 작업을 진행합니다.

즉, 다른 주체가 작업할 때 자신의 제어권이 있는지 없는지를 기준으로 나뉩니다.

한 마디로 요약하면 동기/비동기는 결과의 반환 시점, 블록/논블록은 제어권에 대한 기준입니다.

</div>
</details>

<details>
<summary>멀티스레드와 논블로킹 I/O</summary>
<div markdown="1">

한 프로세스에 스레드가 3개 존재한다고 합시다. T1은 파일을 읽어오는 역할을 담당합니다.
T1의 작업 소요 시간은 읽어오는 파일의 크기와 직결됩니다. 크기가 크다면, 이 파일을 일부 단위로 쪼개서 읽어와야할 수도 있습니다.
T2는 읽어온 파일이 영상이라면, 영상 처리를 하는 작업을 합니다.
보통은 영상을 읽는 것보다 처리를 하는 것이 오래 걸립니다.
그러므로 영상 처리와 영상 읽기 작업을 별도의 스레드에서 처리하는 것이 좋습니다.
그 다음 처리한 영상을 전송하는 작업을 한다고 합니다.
T3는 소켓을 열어서 통신하는 역할을 담당합니다.

이 경우에 T1 -> T2 -> T3의 작업은 순차적으로 이루어져야 합니다. 이 때 등장하는 개념이 동기화입니다.
이 작업이 모두 순서에 맞게 동기화가 되어야 정상적인 작업의 흐름대로 진행되기 때문입니다.

동기화를 위해서 먼저 `Queue`를 사용합니다.
T1은 파일을 읽어서 `Queue 1`에 등록합니다. T2는 루프를 돌면서 `Queue 1`을 감시합니다.
`Queue 1`에 처리할 데이터가 생기면, T2는 영상을 처리해서 `Queue 2`에 등록합니다.
이 때, T2처럼 `Queue 2`를 보고 있던 T3는 그제서야 소켓을 열어 해당 file을 전송합니다.

이 때 주의할 점은 T1, T2 간에, T2, T3 간에 동시에 `Queue`를 접근할 수 있습니다.
그렇기 때문에 항상 `Queue`에서 뭔가를 꺼내거나 삽입할 때에는 lock을 거는 형태로 관리하게 됩니다.

</div>
</details>

## 네트워크
<details>
<summary>UDP와 TCP의 차이점에 대해 설명해주세요</summary>
<div markdown="1">       

UDP는 비연결형 프로토콜로, 신뢰성 있는 통신을 지원하지 않습니다. 송신 측에서는 단지 데이터를 전송할 뿐 수신자가 잘 받았는지 확인하지 않습니다.
(듣고있든 말든 갑자기 전화가 걸려와서 말하고 끊는다)
그렇기 때문에 성능에 큰 이점이 있습니다. 연결이 이루어지지 않기 때문에 1:1, 1:N, N:M 등으로 통신할 수 있습니다. 
지원하는 기능이 없으므로 TCP에 비해 Header 크기가 작고, checksum 필드를 통해 오류 체크정도는 할 수 있습니다.

반면 TCP는 연결지향 프로토콜로 송신측과 수신측이 미리 연결된 상태에서 신뢰성 있는 통신을 하게 됩니다.
(전화를 받으면, 안부를 묻고(3-way handshaking) 용건이 끝나면 인사를 하고(4-way handshaking) 대화를 종료한다.)
TCP는 흐름 제어, 혼잡 제어, 순서 보장 등의 기능을 지원하여 송신 측의 데이터가 잘 전달될 수 있도록 보장해줍니다. 
서버와 클라이언트는 1:1로 연결되는 전 이중 방식이며, 점대점 방식입니다.

</div>
</details>


## 데이터베이스

## 자바
<details>
<summary>* 자바의 Concurrent 패키지는 어떻게 동기화를 하는가?</summary>
<div markdown="1">       

concurrent 패키지의 자료구조들은 모두 멀티스레드 환경에서 동기화가 되도록 구현되어 있습니다.
그럼 어떻게 동기화가 되는 것일까요?
Java의 `ConcurrentLinkedQueue`에 보면 이 자료구조는 아래 링크에 따라 효율적인 논블로킹 알고리즘을 채용했다고 합니다.
https://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf

대략적인 내용은 논블로킹이 되는 구조가 성능에 유리하다는 것이고, lock-free한 알고리즘인 CAS(Compare-And-Swap)이라는 알고리즘이 소개됩니다.
Compare-And-Swap이란 주어진 값과 메모리에 있는 값이 동일하다면 값을 업데이트하고 그렇지 않으면 하지 않는 것입니다.
이는 `synchronized` 처럼 임계 영역에 도달하면 블로킹 시키는 것이 아니라, 모든 스레드를 논블로킹으로 접근할 수 있도록 하되,
작업 시점의 기준값과 메모리 상의 값을 비교하여 일치하면 작업을 수행하고, 일치하지 않으면 중간에 다른 스레드가 끼어들었다고 판단하여 재시도를 합니다.
(`AtomicInteger`의 `getAndSetInt()`를 보면 do-while 문을 통해, compareAndSet이 true일때까지 반복합니다.)

또한, 메모리 상의 값과 비교하기 위해 각 스레드가 캐시가 아닌 메모리에 직접 기록할 수 있도록 `volatile` 키워드를 사용합니다.
매 번 변경된 데이터는 메모리 상에 반영되므로 모든 스레드가 동일한 메모리 상의 값을 참조할 수 있도록 합니다.

일반적으로 lock을 사용하는 것보다 매우 빠르면서도 스레드 세이프하다는 장점이 있습니다.
그러나 compare-and-swap은 `ABA 문제`를 만날 수 있습니다.
compare하는 순간에 old value와 이미 수정된 값이 같은 현상입니다.
이 때 별도의 카운터를 통해 값이 갱신될 때마다 수정하여, 값이 같더라도 카운터 값이 다르면 수정하지 않는 식으로 해결할 수 있다고 합니다.

</div>
</details>

### `*`가 붙은 내용은 이해가 더 필요한 내용입니다.
